# Описание

В данной папке содержится проект выполняющий первое домашнее задание.

В качестве инструмента для управления зависимостями и виртуальным окружением был выбрал показанный нам на лекции `pixi`([ссылка](https://pixi.sh/latest/)).

Данное окружение используется для работы всех трех скриптов имитирующих работу Linux утилит:
* `nl.py` имитирует поведение `nl`
* `tail.py` имитирует поведение `tail`
* `wc.py` имитирует поведение `wc`

# Разворачивание виртуального окружения проекта

Если у нас еще нет утилиты `pixi` устанавливаем ее согласно офф. документации `pixi`([ссылка](https://pixi.sh/latest/)).

После установки `pixi` клонируем корневой репозиторий:
```
git clone https://github.com/medphisiker/python_advanced.git
```

Переходим в каталог проекта домашней работы 1:
```
cd hw1
```

Выполняем команду разворачивания виртуального окружения с помощью `pixi`:
```
pixi install
```

## Активация терминала
Активируем терминал внутри виртуального окружения нашего проекта:
```
pixi shell
```

Теперь мы можем запустить `python-скрипты`.

## Скрипт имитирующий nl

Скрипт с CLI интерфейсом, аналогичный упрощенному варианту утилиты `nl` -- скрипт, который выдает в `stdout` пронумерованные строки из файла.

Если файл не передан, то скрипт читает строки из `stdin`.

Он должен работать так же, как `nl -b a`.

### Тестируем на текстовом файле
Для тестирования работы скрипта `nl.py` выполним команду:
```
python nl.py artifacts/text_for_test.txt
```

Мы увидим в терминале следующий вывод:
```
     1  
     2  
     3  line 3
     4  line 4
     5  line 5
     6  
     7  line 7
     8  line 8
     9  line 9
    10  line 10
    11  
    12  line 12
```

Можно сравнить его с выводом настоящей утилиты `nl`. Выполним команду:
```
nl -b a artifacts/text_for_test.txt
```

Мы увидим в терминале следующий вывод:
```
     1
     2
     3  line 3
     4  line 4
     5  line 5
     6
     7  line 7
     8  line 8
     9  line 9
    10  line 10
    11
    12  line 12
```

Выводы `nl.py` и `nl` совпадают.

### Тестируем на stdin

Для тестирования работы скрипта `nl.py` на `stdin` выполним команду:
```
python nl.py
```

В терминале появится приглашение на ввод данных в `stdin`, вводим любую строку нажимаем `Enter`.
Введем последовательно `1`, `2`, `4` и пару пустых строк.
После этого введем `Ctrl + C`, чтобы остановить выполнение.
Итоговый вывод в терминале:
```
1
     1  1
2
     2  2
4
     3  4

     4  

     5  
^C
Aborted!
```

Можно сравнить его с выводом настоящей утилиты `nl`. Выполним команду:
```
nl -b a
```

В терминале появится приглашение на ввод данных в `stdin`, вводим любую строку нажимаем `Enter`.
Введем последовательно `1`, `2`, `4` и пару пустых строк.
После этого введем `Ctrl + C`, чтобы остановить выполнение.
Итоговый вывод в терминале:
```
1
     1  1
2
     2  2
4
     3  4

     4

     5
^C
```
Интересно, что утилита `nl` не пишет `Aborted!` как `python`.

Выводы `nl.py` и `nl` совпадают.


## Скрипт имитирующий tail

Упрощенный вариант утилиты `tail` -- скрипт, выводящий в `stdout` последние 10 строк каждого из переданных файлов.

* если передано больше одного файла, то перед обработкой очередного файла необходимо вывести его имя. Подробности смотрите в оригинальной утилите `tail`, ваш скрипт должен повторять форматирование.
* если не передано ни одного файла, то нужно вывести последние 17 строк из `stdin`.

### Тестируем на одном текстовом файле
Для тестирования работы скрипта `tail.py` выполним команду:
```
python tail.py -f artifacts/text_for_test.txt
```

Получим вывод в терминал:
```
line 3
line 4
line 5

line 7
line 8
line 9
line 10

line 12
```

Можно сравнить его с выводом настоящей утилиты `tail`. Выполним команду:
```
tail artifacts/text_for_test.txt
```

Получим вывод в терминал:
```
line 3
line 4
line 5

line 7
line 8
line 9
line 10

line 12
```

Видим, что выводы идентичны.

### Тестируем на нескольких текстовых файлах
Для тестирования работы скрипта `tail.py` выполним команду:
```
python tail.py -f artifacts/text_for_test.txt -f artifacts/text_for_test2.txt -f artifacts/text_for_test3.txt
```

Получим вывод в терминал:
```
==> artifacts/text_for_test.txt <==
line 3
line 4
line 5

line 7
line 8
line 9
line 10

line 12

==> artifacts/text_for_test2.txt <==

line2
line3

line5

==> artifacts/text_for_test3.txt <==
line1

```

Можно сравнить его с выводом настоящей утилиты `tail`. Выполним команду:
```
tail artifacts/text_for_test.txt artifacts/text_for_test2.txt artifacts/text_for_test3.txt
```
Получим вывод в терминал:
```
==> artifacts/text_for_test.txt <==
line 3
line 4
line 5

line 7
line 8
line 9
line 10

line 12

==> artifacts/text_for_test2.txt <==

line2
line3

line5

==> artifacts/text_for_test3.txt <==
line1
```

Выводы в терминал совпадают.

### Тестируем на stdin
Для тестирования работы скрипта `tail.py` выполним команду:
```
python tail.py
```

В терминале появится приглашение на ввод данных в `stdin`, вводим любую строку нажимаем `Enter`.

Ввод пустой строки обозначим как "".

Введем последовательно `1`, `2`, `3`, `4`, `5`, "", `7`, `8`, "", `10`, `11`, "", "", `14`, `15`, `16`, `17`.

Итоговый вывод в терминале:
```
1
1

2
2

3
3

4
4

5
5




7
7

8
8




10
10

11
11







14
14

15
15

16
16

17
17
```

## Скрипт имитирующий wc

Скрипт, работающий так же, как утилита `wc`, вызванная без дополнительных опций.
Т.е. для каждого переданного файла утилита выводит статистику (3 числа) и имя файла.

* если передано больше одного файла, то в самом конце утилита выводит суммарную статистику (total)
* если ни одного файла не передано, то утилита считывает весь вход и печатает для него статистику без имени.


### Тестируем на одном текстовом файле
Для тестирования работы скрипта `wc.py` выполним команду:
```
python wc.py -f artifacts/text_for_test.txt
```

Получим вывод в терминал:
```
12 16 62 artifacts/text_for_test.txt
```

Можно сравнить его с выводом настоящей утилиты `wc`. Выполним команду:
```
wc artifacts/text_for_test.txt
```
Получим вывод в терминал:
```
12 16 62 artifacts/text_for_test.txt
```

Выводы в терминал совпадают.

### Тестируем на нескольких текстовых файлах
Для тестирования работы скрипта `wc.py` выполним команду:
```
python wc.py -f artifacts/text_for_test.txt -f artifacts/text_for_test2.txt -f artifacts/text_for_test3.txt
```
Получим вывод в терминал:
```
12 16 62 artifacts/text_for_test.txt
 5  3 20 artifacts/text_for_test2.txt
 1  1  6 artifacts/text_for_test3.txt
18 20 88 total
```

Можно сравнить его с выводом настоящей утилиты `wc`. Выполним команду:
```
wc artifacts/text_for_test.txt artifacts/text_for_test2.txt artifacts/text_for_test3.txt
```
Получим вывод в терминал:
```
12 16 62 artifacts/text_for_test.txt
 5  3 20 artifacts/text_for_test2.txt
 1  1  6 artifacts/text_for_test3.txt
18 20 88 total 
```

Выводы в терминал совпадают.

### Тестируем на stdin
Для тестирования работы скрипта `wc.py` выполним команду:
```
python wc.py
```
Появится приглашение на ввод данных. Введем:
```
1
123
Linux

1
```
Нажмем сочетание клавиш `Ctrl + D`, чтобы остановить ввод в `stdin`.

Получим вывод в терминал:
```
        5       4       15
```

Можно сравнить его с выводом настоящей утилиты `wc`. Выполним команду:
```
wc
```
Появится приглашение на ввод данных. Введем:
```
1
123
Linux

1
```
Нажмем сочетание клавиш `Ctrl + D`, чтобы остановить ввод в `stdin`.

Получим вывод в терминал:
```
      5       4      15
```

Выводы в терминал совпадают, не считая числа знаков в табуляции между значениями.
